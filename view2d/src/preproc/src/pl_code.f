! subversion Id for THIS file : $Id: pl_code.f 8506 2016-01-28 10:09:58Z simonc $
! $URL: http://svn-ae/ae/COMMON/stand-alone/atmos_models/socrates/tags/07.18.01/src/preproc/src/pl_code.f $
!-----------------------------------------------------------------------

      subroutine PL_CODE( spccnt, &
			  clscnt, &
                          clsmap, &
                          cls_rxt_cnt, &
                          cls_rxt_map, &
                          pcoeff_ind, &
                          pcoeff, &
                          permute, &
                          hetcnt, &
                          rxt_alias, &
                          machine, &
			  f90 )
!-----------------------------------------------------------------------
!	... Write the fortran production and loss code
!-----------------------------------------------------------------------
     
      use LIMITS
      use SYMBOLS, only : new_solsym

      implicit none

!-----------------------------------------------------------------------
!        ... The arguments
!
!            The columns of the cls_rxt_cnt represent the reaction count
!	     for each class with the following row conontation:
!		(1) - independent reactions
!		(2) - linear reactions
!		(3) - nonlinear reactions
!		(4) - heterogeneous processes
!-----------------------------------------------------------------------
      integer, intent(in) ::  spccnt, hetcnt
      integer, intent(in) ::  clscnt(5), &
                              clsmap(var_lim,5,2), &
                              cls_rxt_map(rxt_lim,7,5), &
                              cls_rxt_cnt(4,5)
      integer, intent(in) ::  pcoeff_ind(*)
      integer, intent(in) ::  permute(var_lim,5)
      real, intent(in)    ::  pcoeff(4,*)
      character(len=8), intent(in) :: machine
      character(len=8), intent(in) :: rxt_alias(rxt_lim)
      logical, intent(in) ::  f90
      
!-----------------------------------------------------------------------
!        ... Local variables
!-----------------------------------------------------------------------
      integer  ::   i, k, kl, ku, l, m, ml
      integer  ::   length, index, cnt
      integer  ::   line_pos, target
      integer  ::   class
      integer  ::   base
      integer  ::   species
      integer  ::   match_cnt
      integer  ::   other_ind
      integer  ::   rxndx, spndx
      integer  ::   match_ind(4)
      integer  ::   max_loc(1)
      integer  ::   freq(spccnt)
      integer  ::   permutation(var_lim)
      integer, allocatable  ::   indexer(:)
      real     ::   rate
      character(len=72) :: line
      character(len=72) :: buff
      character(len=5)  ::  num
      logical, allocatable :: match_mask(:,:)
      logical, allocatable :: pmask(:,:)
      logical  ::  beg_line, flush
      logical  ::  first_class = .true.
      logical  ::  lexist, first, cache
      
      cache = .not. (machine == 'CRAY')
      INQUIRE( file = 'prd_loss.F', exist = lexist )
      if( lexist ) then
	 call SYSTEM( 'rm prd_loss.F' )
      end if
      OPEN( unit = 30, file = 'prd_loss.F' )

      line = '! DO NOT EDIT THIS FILE!! It was automatically written by'
      write(30,100) TRIM( line )
      line = '! the socpp program. Use that program and its *.in input file'
      write(30,100) TRIM( line )
      line = '! (see directory preproc/ ) to overwrite it'
      write(30,100) TRIM( line )
      line = '!============================================================'
      write(30,100) TRIM( line )
      line = ' '
      write(30,100) TRIM( line )
Class_loop : &
      do class = 1,5
	 if( clscnt(class) == 0 ) then
	    cycle
	 end if
	 select case( class )
	   case( 1 )
              line = '      subroutine EXP_PROD_LOSS( prod'
	   case( 2 )
              line = '      subroutine EBI_PROD_LOSS( prod'
	   case( 3 )
              line = '      subroutine HOV_PROD_LOSS( prod'
	   case( 4 )
              line = '      subroutine IMP_PROD_LOSS( prod'
	   case( 5 )
              line = '      subroutine RODAS_PROD_LOSS( prod'
	 end select
	 write(30,100) TRIM( line )
         line = '     $,                         loss'
         write(30,100) TRIM( line )
         line = '     $,                         y'
         write(30,100) TRIM( line )
         line = '     $,                         rxt'
         write(30,100) TRIM( line )
	 if( cache ) then
            if( hetcnt /= 0 ) then
               line = '     $,                         het_rates'
               write(30,100) TRIM( line )
            end if
            line = '     $,                         converged'
            write(30,100) TRIM( line )
            line = '     $,                         kl, ku )'
            write(30,100) TRIM( line )
	 else
            if( hetcnt /= 0 ) then
               line = '     $,                         het_rates )'
               write(30,100) TRIM( line )
            end if
	 end if
         line = '!--------------------------------------------------------------------'
	 write(30,100) TRIM( line )
         line = '!       ... Production and loss for'
	 length = LEN_TRIM( line ) + 2
	 if( class == 1 ) then
	    line(length:) = 'Explicit method'
	 else if( class == 2 ) then
	    line(length:) = 'Ebi-gs method'
	 else if( class == 3 ) then
	    line(length:) = 'Hov-gs method'
	 else if( class == 4 ) then
	    line(length:) = 'Implicit method'
	 else if( class == 5 ) then
	    line(length:) = 'Rodas3 method'
	 end if
	 write(30,100) TRIM( line )
         line = '!--------------------------------------------------------------------'
	 write(30,100) TRIM( line )
         line = ' '
         write(30,100) TRIM( line )
         if( f90 ) then
            line = '      use RXT_NAMES'
            write(30,100) TRIM( line )
            line = '      use SPC_NAMES'
            write(30,100) TRIM( line )
            line = ' '
            write(30,100) TRIM( line )
            line = ' '
            write(30,100) TRIM( line )
         end if
         line = '      implicit none '
         write(30,100) TRIM( line )
         line = ' '
         write(30,100) TRIM( line )
         line = '!--------------------------------------------------------------------'
         write(30,100) TRIM( line )
         line = '!     ... Dummy arguments'
         write(30,100) TRIM( line )
         line = '!--------------------------------------------------------------------'
         write(30,100) TRIM( line )
	 if( .not. cache ) then
            write(num,'(i5)') clscnt(class)
	    num = ADJUSTL( num )
            line = '      real, intent(out)   ::  prod(PLEV,' // TRIM(num) // ')'
            write(30,100) TRIM( line )
            line = '      real, intent(out)   ::  loss(PLEV,' // TRIM(num) // ')'
            write(30,100) TRIM( line )
            line = '      real, intent(in)    ::  y(PLEV,PCNST)'
            write(30,100) TRIM( line )
            line = '      real, intent(in)    ::  rxt(PLEV,RXNCNT)'
            write(30,100) TRIM( line )
	    if( hetcnt /= 0 ) then
               line = '      real, intent(in)    ::  het_rates(PLEV,HETCNT)'
               write(30,100) TRIM( line )
	    end if
	 else
            line = '      integer, intent(in)   ::  kl, ku'
            write(30,100) TRIM( line )
            write(num,'(i5)') clscnt(class)
	    num = ADJUSTL( num )
            line = '      real, intent(out)   ::  prod(4,' // TRIM(num) // ')'
            write(30,100) TRIM( line )
            line = '      real, intent(out)   ::  loss(4,' // TRIM(num) // ')'
            write(30,100) TRIM( line )
            line = '      real, intent(in)    ::  y(4,PCNST)'
            write(30,100) TRIM( line )
            line = '      real, intent(in)    ::  rxt(4,RXNCNT)'
            write(30,100) TRIM( line )
	    if( hetcnt /= 0 ) then
               line = '      real, intent(in)    ::  het_rates(4,HETCNT)'
               write(30,100) TRIM( line )
	    end if
            line = '      logical, intent(in)   ::  converged(4)'
            write(30,100) TRIM( line )
	 end if
         line = ' '
         write(30,100) TRIM( line )
         line = '!--------------------------------------------------------------------'
         write(30,100) TRIM( line )
         line = '!     ... Local variables'
         write(30,100) TRIM( line )
         line = '!--------------------------------------------------------------------'
         write(30,100) TRIM( line )
         line = '      integer ::  k'
         write(30,100) TRIM( line )
         line = ' '
         write(30,100) TRIM( line )
         buff = ' '

	 if( ALLOCATED( match_mask ) ) then
	    DEALLOCATE( match_mask )
	 end if
	    if( ALLOCATED( pmask ) ) then
	       DEALLOCATE( pmask )
	    end if
	    if( ALLOCATED( indexer ) ) then
	       DEALLOCATE( indexer )
	    end if
	    k = SUM( cls_rxt_cnt(:,class) )
	    if( k == 0 ) then
	       cycle Class_loop
	    end if
	    ALLOCATE( match_mask(k,3) )
	    ALLOCATE( indexer(k) )
	    if( SUM( cls_rxt_cnt(2:3,class) ) /= 0 ) then
	       ALLOCATE( pmask(k,4) )
	    end if
	    if( cache ) then
	       line = '      do k = kl,ku'
               write(30,100) TRIM( line )
	       line = '         if( .not. converged(k) ) then'
	    else
	       line = '      do k = 1,PLEV'
	    end if
            write(30,100) TRIM( line )
100   format(a)

	    if( class == 2 .or. class == 3 ) then
	       line = ' '
	       line(10:) = 'select case( index )'
	       write(30,100) line(:LEN_TRIM(line))
	       line = ' '
	    end if
	    if( class <= 3 ) then
	       permutation(:clscnt(class)) = (/ (i,i=1,clscnt(class)) /)
	    else
	       permutation(:clscnt(class)) = permute(:clscnt(class),class)
	    end if
Species_loop : &
            do species = 1,clscnt(class)
	       if( class == 2  .or. class == 3 ) then
		  write(num,'(i5)') permutation(species)
	          line = ' '
	          line(13:) = 'case( ' // num(:LEN_TRIM(num)) // ' )'
	          write(30,100) line(:LEN_TRIM(line))
	          line = ' '
	       end if
!-----------------------------------------------------------------------
!   	...Write code for loss processes; linear, nonlinear, and heterogeneous
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!   	... Setup indicies and check whether species is in any loss reactions
!-----------------------------------------------------------------------
	       target = clsmap(species,class,2)
	       kl = cls_rxt_cnt(1,class) + 1
	       ku = SUM( cls_rxt_cnt(:3,class) )
	       do i = 1,2
	          match_mask(kl:ku,i) = cls_rxt_map(kl:ku,i+1,class) == target
	          where( match_mask(kl:ku,i) )
	             indexer(kl:ku) = 6/(i+1)
	          endwhere
	       end do
	       match_mask(kl:ku,1) = match_mask(kl:ku,1) .or. match_mask(kl:ku,2)
	       kl = ku + 1 ; ku = SUM(cls_rxt_cnt(:,class))
	       match_mask(kl:ku,1) = cls_rxt_map(kl:ku,2,class) == species
	       kl = cls_rxt_cnt(1,class) + 1
	       write(num,'(i5)') permutation(species)
	       num =  ADJUSTL( num )
	       if( COUNT( match_mask(kl:ku,1) ) == 0 ) then
		  if( f90 ) then
		     if( class /= 4 ) then
	                line(10:) = 'loss(:,' // num(:LEN_TRIM(num)) // ') = 0.'
		     else
	                line(13:) = 'loss(k,' // num(:LEN_TRIM(num)) // ') = 0.'
		     end if
		  else
	             line(13:) = 'loss(k,' // num(:LEN_TRIM(num)) // ') = 0.'
		  end if
	          write(30,100) line(:LEN_TRIM(line))
	       else
	          line = ' '
	          if( class == 1 .or. class >= 4 ) then
		     if( .not. f90 .or. class == 4 ) then
	                line(13:) = 'loss(k,' // num(:LEN_TRIM(num)) // ') = ('
		     else if( f90 ) then
	                line(10:) = 'loss(:,' // num(:LEN_TRIM(num)) // ') = ('
		     end if
	             line_pos = LEN_TRIM( line ) + 1
	          else
		     if( f90 ) then
			if( class /= 4 ) then
	                   line(10:) = 'loss(:,' // num(:LEN_TRIM(num)) // ') ='
			else
	                   line(13:) = 'loss(k,' // num(:LEN_TRIM(num)) // ') ='
			end if
		     else
	                line(13:) = 'loss(k,' // num(:LEN_TRIM(num)) // ') ='
		     end if
	             line_pos = LEN_TRIM( line ) + 2
	          end if
!-----------------------------------------------------------------------
!	... Scan loss reactions for common terms
!-----------------------------------------------------------------------
	          ku = ku - cls_rxt_cnt(4,class)
		  first = .true.
	          do m = 1,spccnt
		     match_mask(kl:ku,2) = .false.
		     do k = kl,ku
			if( match_mask(k,1) ) then
			   if( ABS( cls_rxt_map(k,indexer(k),class) ) == m ) then
			      match_mask(k,2) = .true.
			   end if
			end if
		     end do
		     cnt = COUNT( match_mask(kl:ku,2) )
		     if( cnt == 0 ) then
		        cycle
		     end if
		     if( m == target ) then
		        if( cnt > 1 ) then
			   if( first ) then
		              buff = '2.*('
		           else
		              buff = ' + 2.*('
			   end if
		        else
			   if( first ) then
		              buff = '2.*'
		           else
		              buff = ' + 2.*'
			   end if
		        end if
		     else
		        if( cnt > 1 ) then
			   if( first ) then
		              buff = '('
		           else
		              buff = ' + ('
			   end if
		        else
			   if( first ) then
		              buff = ' '
		           else
		              buff = ' + '
			   end if
		        end if
		     end if
		     if( first ) then
			first = .false.
		     end if
		     l = 0
		     do k = kl,ku
		        if( match_mask(k,2) ) then
			   l = l + 1
			   rxndx = cls_rxt_map(k,1,class)
	                   write(num,'(i5)') rxndx
	                   num =  ADJUSTL( num )
		           if( f90 ) then
			      if( class /= 4 ) then
		                 buff(LEN_TRIM(buff)+1:) = 'rxt(:,rid_' // rxt_alias(rxndx)(:LEN_TRIM(rxt_alias(rxndx))) // ') +'
			      else
		                 buff(LEN_TRIM(buff)+1:) = 'rxt(k,rid_' // rxt_alias(rxndx)(:LEN_TRIM(rxt_alias(rxndx))) // ') +'
			      end if
		           else
		              buff(LEN_TRIM(buff)+1:) = 'rxt(k,' // num(:LEN_TRIM(num)) // ') +'
		           end if
			   if( l == cnt ) then
		              if( cnt > 1 ) then
			         buff(LEN_TRIM(buff)-1:) = ')'
			      else
			         buff(LEN_TRIM(buff)-1:) = ' '
			      end if
			      call PUT_IN_LINE()
			      write(num,'(i5)') m
	                      num =  ADJUSTL( num )
			      if( f90 ) then
				 if( class == 4 ) then
		                    buff(LEN_TRIM(buff)+1:) = '*y(k,vid_' // new_solsym(m)(:LEN_TRIM(new_solsym(m))) // ')'
				 else
		                    buff(LEN_TRIM(buff)+1:) = '*y(:,vid_' // new_solsym(m)(:LEN_TRIM(new_solsym(m))) // ')'
				 end if
			      else
		                 buff(LEN_TRIM(buff)+1:) = '* y(k,' // num(:LEN_TRIM(num)) // ')'
			      end if
			   end if
			   call PUT_IN_LINE()
		        end if
		     end do
		     where( match_mask(kl:ku,2) )
		        match_mask(kl:ku,1) = .false.
		     endwhere
	          end do
!-----------------------------------------------------------------------
!	... Strictly unimolecular losses
!-----------------------------------------------------------------------
	          ku = SUM( cls_rxt_cnt(:,class) )
	          cnt = COUNT( match_mask(kl:ku,1) )
		  if( cnt > 0 ) then
	             do k = kl,ku
		        if( match_mask(k,1) ) then
		           cnt = cnt - 1
			   rxndx = cls_rxt_map(k,1,class)
	                   write(num,'(i5)') rxndx
	                   num =  ADJUSTL( num )
			   if( k <= SUM(cls_rxt_cnt(1:3,class)) ) then
		              if( f90 ) then
				 if( class /= 4 ) then
		                    buff(LEN_TRIM(buff)+1:) = ' + rxt(:,rid_' // rxt_alias(rxndx)(:LEN_TRIM(rxt_alias(rxndx))) // ')'
				 else
		                    buff(LEN_TRIM(buff)+1:) = ' + rxt(k,rid_' // rxt_alias(rxndx)(:LEN_TRIM(rxt_alias(rxndx))) // ')'
				 end if
		              else
		                 buff(LEN_TRIM(buff)+1:) = ' + rxt(k,' // num(:LEN_TRIM(num)) // ')'
		              end if
		           else
		              if( f90 ) then
				 if( class /= 4 ) then
		                    buff(LEN_TRIM(buff)+1:) = ' + het_rates(:,' // num(:LEN_TRIM(num)) // ')'
				 else
		                    buff(LEN_TRIM(buff)+1:) = ' + het_rates(k,' // num(:LEN_TRIM(num)) // ')'
				 end if
		              else
		                 buff(LEN_TRIM(buff)+1:) = ' + het_rates(k,' // num(:LEN_TRIM(num)) // ')'
		              end if
		           end if
	                   if( cnt == 0 .and. (class == 1 .or. class >= 4) ) then
		              buff(LEN_TRIM(buff)+1:) = ')'
		           end if
		           call PUT_IN_LINE()
		        end if
	             end do
		  else if( class == 1 .or. class >= 4 ) then
		     buff(LEN_TRIM(buff)+1:) = ')'
		     call PUT_IN_LINE()
		  end if
		  flush = .false.
		  if( class == 1 .or. class >= 4 ) then
	             write(num,'(i5)') target
	             num =  ADJUSTL( num )
	             if( f90 ) then
			if( class /= 4 ) then
		           buff(LEN_TRIM(buff)+1:) = '*y(:,vid_' // new_solsym(target)(:LEN_TRIM(new_solsym(target))) // ')'
			else
		           buff(LEN_TRIM(buff)+1:) = '*y(k,vid_' // new_solsym(target)(:LEN_TRIM(new_solsym(target))) // ')'
			end if
	             else
		        buff(LEN_TRIM(buff)+1:) = '* y(k,' // num(:LEN_TRIM(num)) // ')'
		     end if
		     call PUT_IN_LINE()
		  end if
	          if( line(7:) /= ' ' ) then
		     write(30,100) line(:LEN_TRIM(line))
	          end if
	       end if
!-----------------------------------------------------------------------
!   	...Write code for production from linear and nonlinear reactions
!-----------------------------------------------------------------------
	       ku = SUM( cls_rxt_cnt(:3,class) )
	       do k = kl,ku
		  pmask(k,:) = cls_rxt_map(k,4:7,class) == species
	          match_mask(k,1) = ANY( pmask(k,:) )
	       end do
	       write(num,'(i5)') permutation(species)
	       num =  ADJUSTL( num )
	       line = ' '
!-----------------------------------------------------------------------
!	... No species products
!-----------------------------------------------------------------------
	       if( COUNT( match_mask(kl:ku,1) ) == 0 ) then
	          if( class == 4 .or. .not. f90 ) then
	             line(13:) = 'prod(k,' // num(:LEN_TRIM(num)) // ') = 0.'
	          else if( f90 ) then
	             line(10:) = 'prod(:,' // num(:LEN_TRIM(num)) // ') = 0.'
	          end if
		  write(30,100) line(:LEN_TRIM(line))
		  cycle Species_loop
	       else
	          if( class == 4 .or. .not. f90 ) then
	             line(13:) = 'prod(k,' // num(:LEN_TRIM(num)) // ') = '
	          else if( f90 ) then
	             line(10:) = 'prod(:,' // num(:LEN_TRIM(num)) // ') = '
	          end if
	       end if
	       first = .true.
	       do
	          do m = 1,spccnt
		     match_mask(kl:ku,3) = (ABS(cls_rxt_map(kl:ku,2,class)) == m .or. &
		                           ABS(cls_rxt_map(kl:ku,3,class)) == m) .and.&
					   match_mask(kl:ku,1)
		     freq(m) = COUNT( match_mask(kl:ku,3) )
	          end do
		  max_loc = MAXLOC( freq(:spccnt) )
		  cnt = MAXVAL( freq(:spccnt) )
		  match_mask(kl:ku,3) = (ABS(cls_rxt_map(kl:ku,2,class)) == max_loc(1) .or. &
		                        ABS(cls_rxt_map(kl:ku,3,class)) == max_loc(1)) .and. &
					match_mask(kl:ku,1)
		  do k = kl,ku
		     if( match_mask(k,3) ) then
			if( ABS( cls_rxt_map(k,2,class) ) == max_loc(1) ) then
			   indexer(k) = 3
			else
			   indexer(k) = 2
			end if
		     end if
		  end do
		  if( cnt > 1 ) then
		     if( first ) then
		        buff = ' ('
		     else
		        buff = ' + ('
		     end if
		  else if( first ) then
		     buff = ' '
		  else
		     buff = ' +'
		  end if
		  if( first ) then
		     first = .false.
		  end if
		  m = cnt
		  do k = kl,ku
		     if( match_mask(k,3) ) then
		        index = pcoeff_ind(cls_rxt_map(k,1,class))
!		rate = SUM( pcoeff(:,index), mask = pmask(k,:) )
			rate = 0.
			do ml = 1,4
			   if( pmask(k,ml) ) then
			      rate = rate + pcoeff(ml,index)
			   end if
			end do
		        if( rate /= 0. .and. rate /= 1. ) then
			   call R2C( buff(LEN_TRIM(buff)+1:), rate, 'l' )
			   buff(LEN_TRIM( buff )+1:) = '*'
		        end if
	                rxndx = cls_rxt_map(k,1,class)
	                write(num,'(i5)') rxndx
	                num =  ADJUSTL( num )
			if( f90 ) then
			   if( class /= 4 ) then
		              buff(LEN_TRIM(buff)+1:) = 'rxt(:,rid_' // rxt_alias(rxndx)(:LEN_TRIM(rxt_alias(rxndx))) // ')'
			   else
		              buff(LEN_TRIM(buff)+1:) = 'rxt(k,rid_' // rxt_alias(rxndx)(:LEN_TRIM(rxt_alias(rxndx))) // ')'
			   end if
			else
		           buff(LEN_TRIM(buff)+1:) = 'rxt(k,' // num(:LEN_TRIM(num)) // ')'
			end if
			if( ABS( cls_rxt_map(k,indexer(k),class) ) /= 0 ) then
	                   spndx = ABS( cls_rxt_map(k,indexer(k),class) )
	                   write(num,'(i5)') spndx
	                   num =  ADJUSTL( num )
			   if( f90 ) then
			      if( class /= 4 ) then
			         if( m > 1 ) then
		                    buff(LEN_TRIM(buff)+1:) = '*y(:,vid_' // new_solsym(spndx)(:LEN_TRIM(new_solsym(spndx))) // ') +'
			         else if( cnt > 1 ) then
		                    buff(LEN_TRIM(buff)+1:) = '*y(:,vid_' // new_solsym(spndx)(:LEN_TRIM(new_solsym(spndx))) // '))' 
			         else
		                    buff(LEN_TRIM(buff)+1:) = '*y(:,vid_' // new_solsym(spndx)(:LEN_TRIM(new_solsym(spndx))) // ')' 
			         end if
			      else
			         if( m > 1 ) then
		                    buff(LEN_TRIM(buff)+1:) = '*y(k,vid_' // new_solsym(spndx)(:LEN_TRIM(new_solsym(spndx))) // ') +'
			         else if( cnt > 1 ) then
		                    buff(LEN_TRIM(buff)+1:) = '*y(k,vid_' // new_solsym(spndx)(:LEN_TRIM(new_solsym(spndx))) // '))' 
			         else
		                    buff(LEN_TRIM(buff)+1:) = '*y(k,vid_' // new_solsym(spndx)(:LEN_TRIM(new_solsym(spndx))) // ')' 
			         end if
			      end if
			   else if( m > 1 ) then
		              buff(LEN_TRIM(buff)+1:) = '*y(k,' // num(:LEN_TRIM(num)) // ') +'
			   else if( cnt > 1 ) then
		              buff(LEN_TRIM(buff)+1:) = '*y(k,' // num(:LEN_TRIM(num)) // '))'
			   else
		              buff(LEN_TRIM(buff)+1:) = '*y(k,' // num(:LEN_TRIM(num)) // ')'
			   end if
			else
			   if( f90 ) then
			      if( m > 1 ) then
		                 buff(LEN_TRIM(buff)+1:) = ' +'
			      else if( cnt > 1 ) then
		                 buff(LEN_TRIM(buff)+1:) = ')'
			      end if
			   else if( m > 1 ) then
		              buff(LEN_TRIM(buff)+1:) = ' +'
			   else if( cnt > 1 ) then
		              buff(LEN_TRIM(buff)+1:) = ')'
			   end if
			end if
			call PUT_IN_LINE()
			if( m == 1 ) then
	                   spndx = max_loc(1)
	                   write(num,'(i5)') spndx
	                   num =  ADJUSTL( num )
			   if( f90 ) then
			      if( class /= 4 ) then
		                 buff = '*y(:,vid_' // new_solsym(spndx)(:LEN_TRIM(new_solsym(spndx))) // ')' 
			      else
		                 buff = '*y(k,vid_' // new_solsym(spndx)(:LEN_TRIM(new_solsym(spndx))) // ')' 
			      end if
			   else
		              buff = '*y(k,' // num(:LEN_TRIM(num)) // ')'
			   end if
			   call PUT_IN_LINE()
			   exit
			end if
			m = m - 1
		     end if
		  end do
		  where( match_mask(kl:ku,3) )
		     match_mask(kl:ku,1) = .false.
		  endwhere
		  if( COUNT( match_mask(kl:ku,1) ) == 0 ) then
		     exit
		  end if
	       end do
	       if( line(7:) /= ' ' ) then
		  write(30,100) line(:LEN_TRIM(line))
		  line = ' '
	       end if
	    end do Species_loop
	    if( class == 2 .or. class == 3 ) then
	       line = ' '
	       line(10:) = 'end select'
	       write(30,100) line(:LEN_TRIM(line))
	       line = ' '
	    end if

         if( cache ) then
            line = '         end if'
            write(30,100) TRIM( line )
         end if
         line = '      end do'
         write(30,100) TRIM( line )
         line = ' '
         write(30,100) TRIM( line )
         select case( class )
	   case( 1 )
              line = '      end subroutine EXP_PROD_LOSS'
	   case( 2 )
              line = '      end subroutine HOV_PROD_LOSS'
	   case( 3 )
              line = '      end subroutine EBI_PROD_LOSS'
	   case( 4 )
              line = '      end subroutine IMP_PROD_LOSS'
	   case( 5 )
              line = '      end subroutine RODAS_PROD_LOSS'
         end select
         write(30,100) TRIM( line )
      end do Class_loop

      CLOSE( 30 )
      if( ALLOCATED( match_mask ) ) then
	 DEALLOCATE( match_mask )
      end if
      if( ALLOCATED( pmask ) ) then
	 DEALLOCATE( pmask )
      end if
      if( ALLOCATED( indexer ) ) then
	 DEALLOCATE( indexer )
      end if

      CONTAINS

      subroutine PUT_IN_LINE( )
!-----------------------------------------------------------------------
!	... Put line piece in buff into the line
!-----------------------------------------------------------------------

      implicit none

!-----------------------------------------------------------------------
!	... Local variables
!-----------------------------------------------------------------------
      integer :: blen, llen

      blen = LEN_TRIM( buff )
      llen = LEN_TRIM( line ) + 1
      if( blen + llen < 70 ) then
	 line(llen:) = buff(:blen)
	 flush = .false.
      else
	 write(30,'(a)') line(:LEN_TRIM(line))
	 flush = .true.
	 line = ' '
	 line(6:6) = '$'
	 line(18:) = buff(:blen)
      end if
      buff = ' '

      end subroutine PUT_IN_LINE

      end subroutine PL_CODE
